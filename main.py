#!/usr/bin/python3

import os
import sys
import argparse
import re
import gi
gi.require_version('GIRepository', '2.0')
from gi.repository import GIRepository
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass
from enum import Enum, auto

class PropertyType(Enum):
    STRING = auto()
    INT32 = auto()
    UINT32 = auto()
    INT64 = auto()
    UINT64 = auto()
    FLOAT32 = auto()
    FLOAT64 = auto()
    BOOLEAN = auto()
    OBJECT = auto()
    CUSTOM = auto()  # For user-defined types

@dataclass
class Property:
    name: str
    prop_type: PropertyType
    rust_type: str
    default_value: str
    nullable: bool = False
    doc: Optional[str] = None

@dataclass
class Signal:
    name: str
    params: List[Tuple[str, str]]  # List of (param_name, param_type)
    return_type: Optional[str] = None

class RustGObjectGenerator:
    VALID_IDENTIFIER = re.compile(r'^[A-Za-z][A-Za-z0-9_]*$')
    VALID_CLASSNAME = re.compile(r'^[A-Z][A-Za-z0-9]*$')
    
    TYPE_MAPPING = {
        'string': (PropertyType.STRING, 'String', '""'),
        'str': (PropertyType.STRING, 'String', '""'),
        'i32': (PropertyType.INT32, 'i32', '0'),
        'u32': (PropertyType.UINT32, 'u32', '0'),
        'i64': (PropertyType.INT64, 'i64', '0'),
        'u64': (PropertyType.UINT64, 'u64', '0'),
        'f32': (PropertyType.FLOAT32, 'f32', '0.0'),
        'f64': (PropertyType.FLOAT64, 'f64', '0.0'),
        'bool': (PropertyType.BOOLEAN, 'bool', 'false'),
        'boolean': (PropertyType.BOOLEAN, 'bool', 'false'),
        'object': (PropertyType.OBJECT, 'glib::Object', 'None'),
    }

    def __init__(self):
        self.imp_template = '''// Generated by RustGObjectGenerator
// This file is licensed under the same terms as the project it belongs to

use gtk::{{glib, prelude::*, subclass::prelude::*}};
use glib::subclass::Signal;
use glib::Properties;
use std::cell::RefCell;
use std::sync::OnceLock;
{additional_imports}

mod imp {{
    use super::*;

    #[derive(Properties, Default, gtk::CompositeTemplate)]
    #[properties(wrapper_type = super::{class_name})]
    #[template(file = "{template_file}")]
    pub struct {class_name} {{
{properties}
{template_children}
    }}

    #[glib::derived_properties]
    impl ObjectImpl for {class_name} {{
        fn constructed(&self) {{
            self.parent_constructed();
            let obj = self.obj();
            // Initialize default state here if needed
        }}

        fn signals() -> &'static [Signal] {{
            static SIGNALS: OnceLock<Vec<Signal>> = OnceLock::new();
            SIGNALS.get_or_init(|| vec![
{signals}
            ])
        }}
    }}

    #[glib::object_subclass]
    impl ObjectSubclass for {class_name} {{
        const NAME: &'static str = "{class_name}";
        type Type = super::{class_name};
        type ParentType = {parent_class};

        fn class_init(klass: &mut Self::Class) {{
            klass.bind_template();
            klass.bind_template_callbacks();
        }}

        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {{
            obj.init_template();
        }}
    }}

    impl WidgetImpl for {class_name} {{
        fn size_allocate(&self, width: i32, height: i32, baseline: i32) {{
            self.parent_size_allocate(width, height, baseline);
        }}

        fn snapshot(&self, snapshot: &gtk::Snapshot) {{
            self.parent_snapshot(snapshot);
        }}
    }}

    #[gtk::template_callbacks]
    impl {class_name} {{
{template_callbacks}
    }}
}}

glib::wrapper! {{
    pub struct {class_name}(ObjectSubclass<imp::{class_name}>)
        @extends {', '.join(self.get_parent_hierarchy(parent_class))},
        @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget;
}}

impl {class_name} {{
    pub fn new() -> Self {{
        glib::Object::new()
    }}

    pub fn new_with_params({constructor_params}) -> Self {{
        glib::Object::builder()
{property_builders}
            .build()
    }}

{additional_methods}
}}

// Implement Debug trait
impl std::fmt::Debug for {class_name} {{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        f.debug_struct("{class_name}")
{debug_fields}
            .finish()
    }}
}}'''

    def validate_class_name(self, name: str) -> bool:
        """Validate class name follows Rust naming conventions."""
        return bool(self.VALID_CLASSNAME.match(name))

    def validate_identifier(self, name: str) -> bool:
        """Validate identifier follows Rust naming conventions."""
        return bool(self.VALID_IDENTIFIER.match(name))

    def parse_property(self, prop_str: str) -> Property:
        """Parse property string into Property object with validation."""
        try:
            # Handle optional documentation
            if '#' in prop_str:
                prop_str, doc = prop_str.split('#', 1)
                doc = doc.strip()
            else:
                doc = None

            # Split name and type
            if ':' not in prop_str:
                raise ValueError("Property must be in format 'name:type'")
                
            name, type_str = prop_str.split(':', 1)
            name = name.strip()
            type_str = type_str.strip()
            
            if not self.validate_identifier(name):
                raise ValueError(f"Invalid property name: {name}")
            
            # Handle nullable types
            nullable = type_str.endswith('?')
            if nullable:
                type_str = type_str[:-1]
            
            # Handle custom types
            if type_str.lower() not in self.TYPE_MAPPING:
                # Assume it's a custom type
                return Property(
                    name=name,
                    prop_type=PropertyType.CUSTOM,
                    rust_type=type_str,
                    default_value='None' if nullable else f'{type_str}::default()',
                    nullable=nullable,
                    doc=doc
                )
            
            # Handle built-in types
            type_str = type_str.lower()
            prop_type, rust_type, default_value = self.TYPE_MAPPING[type_str]
            
            if nullable:
                rust_type = f'Option<{rust_type}>'
                default_value = 'None'
            
            return Property(
                name=name,
                prop_type=prop_type,
                rust_type=rust_type,
                default_value=default_value,
                nullable=nullable,
                doc=doc
            )
            
        except ValueError as e:
            raise ValueError(f"Invalid property format. Expected 'name:type[?] #doc', got '{prop_str}'. {str(e)}")

    def parse_signal(self, signal_str: str) -> Signal:
        """Parse signal string into Signal object with validation."""
        try:
            # Handle return type if present
            if '->' in signal_str:
                signal_str, return_type = signal_str.split('->', 1)
                return_type = return_type.strip()
            else:
                return_type = None

            # Handle parameters if present
            if '(' in signal_str:
                name, params_str = signal_str.split('(', 1)
                params_str = params_str.rstrip(')')
                name = name.strip()
                params = []
                
                if params_str:
                    for param in params_str.split(','):
                        param = param.strip()
                        if not param:
                            continue
                        if ':' in param:
                            param_name, param_type = param.split(':', 1)
                            param_name = param_name.strip()
                            param_type = param_type.strip()
                            if not self.validate_identifier(param_name):
                                raise ValueError(f"Invalid parameter name: {param_name}")
                            params.append((param_name, param_type))
                        else:
                            raise ValueError(f"Invalid parameter format: {param}")
            else:
                name = signal_str.strip()
                params = []

            if not self.validate_identifier(name):
                raise ValueError(f"Invalid signal name: {name}")
                
            return Signal(name=name, params=params, return_type=return_type)
                
        except ValueError as e:
            raise ValueError(f"Invalid signal format. Expected 'name(param:type,...) -> return_type' or 'name', got '{signal_str}'. {str(e)}")

    def generate_properties_code(self, properties: List[Property]) -> str:
        """Generate Rust code for properties."""
        prop_lines = []
        for prop in properties:
            # Add documentation if present
            if prop.doc:
                prop_lines.append(f'        /// {prop.doc}')
            
            # Handle different property types
            if prop.prop_type == PropertyType.OBJECT or prop.nullable:
                prop_lines.append(f'        #[property(get, set)]\n        {prop.name}: RefCell<Option<{prop.rust_type}>>,')
            else:
                prop_lines.append(f'        #[property(get, set)]\n        {prop.name}: RefCell<{prop.rust_type}>,')
        
        return '\n'.join(prop_lines) if prop_lines else '        // No properties defined'

    def generate_signals_code(self, signals: List[Signal]) -> str:
        """Generate Rust code for signals."""
        signal_lines = []
        for signal in signals:
            builder = f'Signal::builder("{signal.name}")'
            
            if signal.params:
                params_str = ', '.join(f'("{name}", {type_})' for name, type_ in signal.params)
                builder += f'\n                    .param_types([{params_str}])'
            
            if signal.return_type:
                builder += f'\n                    .return_type::<{signal.return_type}>()'
            
            builder += '\n                    .build(),'
            signal_lines.append(builder)
            
        return '\n'.join(signal_lines) if signal_lines else '                // No signals defined'

    def generate_template_children(self, children: List[str]) -> str:
        """Generate template children code."""
        if not children:
            return "        // No template children defined"
            
        lines = []
        for child in children:
            name, type_ = child.split(':')
            lines.append(f'        #[template_child]\n        pub {name}: TemplateChild<{type_}>,')

        return '\n'.join(lines)

    def generate_template_callbacks(self, callbacks: List[str]) -> str:
        """Generate template callback methods."""
        if not callbacks:
            return "        // No template callbacks defined"
            
        lines = []
        for callback in callbacks:
            lines.append(f'        #[template_callback]\n        {callback}')
            
        return '\n'.join(lines)

    def generate_additional_methods(self, properties: List[Property], signals: List[Signal]) -> str:
        """Generate additional helper methods."""
        methods = []
        
        # Generate signal emission methods
        for signal in signals:
            params_str = ', '.join(f'{name}: {type_}' for name, type_ in signal.params)
            method_name = f"emit_{signal.name}"
            if params_str:
                methods.append(f'''    pub fn {method_name}(&self, {params_str}) {{
        self.emit_by_name::<()>("{signal.name}", &[{', '.join(n for n, _ in signal.params)}]);
    }}''')
            else:
                methods.append(f'''    pub fn {method_name}(&self) {{
        self.emit_by_name::<()>("{signal.name}", &[]);
    }}''')

        return '\n\n'.join(methods)

    def get_parent_hierarchy(self, parent_class: str) -> List[str]:
        """Get the full parent hierarchy using gobject-introspection."""
        repo = GIRepository.Repository.get_default()
        
        # Try to find the parent class in GIRepository
        try:
            # Remove any namespace prefix if present
            if '.' in parent_class:
                namespace, classname = parent_class.rsplit('.', 1)
                repo.require(namespace, None, 0)
            else:
                # Try common GTK namespaces
                for ns in ['Gtk', 'GObject', 'GLib']:
                    try:
                        repo.require(ns, None, 0)
                        classname = parent_class
                        break
                    except:
                        continue
                else:
                    return [parent_class]

            # Get the parent type info
            parent_info = repo.find_by_name(namespace, classname)
            if not parent_info:
                return [parent_class]

            # Walk up the hierarchy
            hierarchy = []
            current = parent_info
            while current:
                hierarchy.append(f'{current.get_namespace()}.{current.get_name()}')
                current = current.get_parent()
            
            # Convert to Rust-style type names
            return [t.replace('Gtk.', 'gtk::')
                       .replace('GObject.', 'glib::')
                       .replace('GLib.', 'glib::')
                    for t in reversed(hierarchy)]
            
        except Exception as e:
            print(f"Warning: Could not get parent hierarchy for {parent_class}: {e}")
            return [parent_class]

    def generate_code(self, class_name: str, parent_class: str, 
                     properties: List[str], signals: List[str], 
                     template_file: Optional[str] = None,
                     template_children: Optional[List[str]] = None,
                     template_callbacks: Optional[List[str]] = None,
                     additional_imports: Optional[List[str]] = None) -> str:
        """Generate complete Rust code for the GObject class."""
        try:
            if not self.validate_class_name(class_name):
                raise ValueError(f"Invalid class name: {class_name}")

            # Parse properties and signals
            parsed_properties = [self.parse_property(prop) for prop in properties]
            parsed_signals = [self.parse_signal(signal) for signal in signals]

            # Handle template file path
            template_path = template_file.replace('\\', '\\\\') if template_file else ""

            # Generate the code
            return self.imp_template.format(
                class_name=class_name,
                parent_class=parent_class,
                additional_imports='\n'.join(additional_imports or []),
                template_file=template_path if template_path else "",
                template_children=self.generate_template_children(template_children or []),
                template_callbacks=self.generate_template_callbacks(template_callbacks or []),
                properties=self.generate_properties_code(parsed_properties),
                signals=self.generate_signals_code(parsed_signals),
                constructor_params=self.generate_constructor_params(parsed_properties),
                property_builders=self.generate_property_builders(parsed_properties),
                additional_methods=self.generate_additional_methods(parsed_properties, parsed_signals),
                debug_fields=self.generate_debug_fields(parsed_properties)
            )
        except Exception as e:
            raise RuntimeError(f"Error generating code: {str(e)}")


    def generate_constructor_params(self, properties: List[Property]) -> str:
        return ', '.join(f'{p.name}: {p.rust_type}' for p in properties)

    def generate_property_builders(self, properties: List[Property]) -> str:
        return '\n'.join(f'            .property("{p.name}", {p.name})' 
                        for p in properties)

    def generate_debug_fields(self, properties: List[Property]) -> str:
        return '\n'.join(f'            .field("{p.name}", &self.property::<{p.rust_type}>("{p.name}"))'
                        for p in properties)

def main():
    parser = argparse.ArgumentParser(description='Create a new GObject class in Rust')
    parser.add_argument('class_name', help='The class name in PascalCase')
    parser.add_argument('parent_class', help='The parent class name')
    parser.add_argument('--properties', nargs='*', help='Properties in format name:type', default=[])
    parser.add_argument('--signals', nargs='*', help='Signal names, optionally with parameters: name(param:type)', default=[])
    parser.add_argument('--imports', nargs='*', help='Additional imports', default=[])
    parser.add_argument('--template', help='Path to template UI file', default=None)
    parser.add_argument('--template-children', nargs='*', 
                       help='Template children in format name:type', default=[])
    parser.add_argument('--template-callbacks', nargs='*',
                       help='Template callback methods', default=[])
    parser.add_argument('path', help='Output path for the Rust file')
    
    args = parser.parse_args()

    try:
        # Create generator instance
        generator = RustGObjectGenerator()

        # Generate the code
        rust_code = generator.generate_code(
            class_name=args.class_name,
            parent_class=args.parent_class,
            properties=args.properties,
            signals=args.signals,
            template_file=args.template,
            template_children=args.template_children,
            template_callbacks=args.template_callbacks,
            additional_imports=args.imports
        )

        # Ensure output directory exists
        os.makedirs(args.path, exist_ok=True)
        
        # Write to file
        output_path = os.path.join(args.path, f"{args.class_name.lower()}.rs")
        with open(output_path, 'w') as f:
            f.write(rust_code)
            
        print(f"Successfully generated {output_path}")
        
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
